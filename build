#!/usr/bin/env bash
# shellcheck disable=SC1117
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# Copyright (C) 2016-2018 USBhost
# Copyright (C) 2016-2017 Joe Maples
# Copyright (C) 2017-2018 Nathan Chancellor
#
# GCC cross compiler  compilation script


###########
# SOURCES #
###########

# http://preshing.com/20141119/how-to-build-a-gcc-cross-compiler/ # credits for almost everything
# http://www.mpfr.org/
# https://gmplib.org/
# http://www.multiprecision.org/
# http://isl.gforge.inria.fr/
# https://www.gnu.org/software/binutils/
# https://www.gnu.org/software/libc/
# https://www.kernel.org/
# https://git.linaro.org/toolchain/gcc.git # linaro and gnu


#############
# FUNCTIONS #
#############

set -e

COMMON_CONFIG="${BASH_SOURCE%/*}/configs/common.sh"
TAR_CONFIG="${BASH_SOURCE%/*}/configs/tar_source_config.sh"
GIT_CONFIG="${BASH_SOURCE%/*}/configs/git_source_config.sh"
TARGET_CONFIG="${BASH_SOURCE%/*}/configs/target_config.sh"
source ${COMMON_CONFIG}
source ${TAR_CONFIG}
source ${GIT_CONFIG}
source ${TARGET_CONFIG}


# Easy alias for escape codes
function echo() {
    command echo -e "${@}"
}


# Help menu function
function help_menu() {
    echo
    echo "${BOLD}OVERVIEW:${RST} Build a gcc toolchain"
    echo
    echo "${BOLD}USAGE:${RST} ${0} <options>"
    echo
    echo "${BOLD}EXAMPLE:${RST} ${0} -a arm64 -s linaro -v 7"
    echo
    echo "${BOLD}REQUIRED PARAMETERS:${RST}"
    echo "  -a  | --arch:        Possible values: arm, arm64, i686, or x86_64. This is the toolchain's target architecture."
    echo "  -s  | --source:      Possible values: gnu or linaro. This is the GCC source (GNU official vs. Linaro fork)."
    echo "  -v  | --version:     Possible values: (4, 5, 6, 7, 8*, and 9* [*GNU only]). This is the GCC version to build."
    echo
    echo "${BOLD}OPTIONAL PARAMETERS:${RST}"
    echo "  -f  | --full-src:    Download full git repos instead of shallow clones"
    echo "  -nu | --no-update:   Do not update the downloaded components before building (useful if you have slow internet)."
    echo "  -p  | --package:     Possible values: gz or xz. Compresses toolchain after build."
    echo "  -t  | --tarballs:    Use tarballs for binutils, ISL, and, GCC"
    echo "  -V  | --verbose:     Make script print all output, not just errors and the ending information"
    echo
}


# Prints a formatted header to let the user know what's being done
function header() {

    # Enable at least the header output
    [[ -z ${VERBOSE} ]] && exec 1>&5 2>&6

    [[ "${*}" =~ "--no-first-echo" ]] || echo
    # shellcheck disable=SC2034
    echo "${GRN}====$(for i in $(seq ${#1}); do echo "=\c"; done)===="
    echo "==  ${1}  =="
    # shellcheck disable=SC2034
    echo "====$(for i in $(seq ${#1}); do echo "=\c"; done)====${RST}"
    [[ "${*}" =~ "--no-second-echo" ]] || echo

    [[ -z ${VERBOSE} ]] && exec 6>&2 5>&1 &>/dev/null

    # this is necessary for whatever reason, otherwise it stops if
    # verbose is set
    echo ""
}


# Prints an error in bold red
function die() {
    [[ -z ${VERBOSE} ]] && exec 1>&5 2>&6
    echo ""
    echo "${RED}${1}${RST}"
    [[ "${*}" =~ "-n" ]] && echo
    [[ "${*}" =~ "-h" ]] && help_menu
    exit
}


# Prints a warning in bold yellow
function warn() {
    echo ""
    echo "${YLW}${1}${RST}"
    [[ "${*}" =~ "-n" ]] && echo
}


# Formats the time for the end
function format_time() {
    MINS=$(((${2} - ${1}) / 60))
    SECS=$(((${2} - ${1}) % 60))
    if [[ ${MINS} -ge 60 ]]; then
        HOURS=$((MINS / 60))
        MINS=$((MINS % 60))
    fi

    if [[ ${HOURS} -eq 1 ]]; then
        TIME_STRING+="1 HOUR, "
    elif [[ ${HOURS} -ge 2 ]]; then
        TIME_STRING+="${HOURS} HOURS, "
    fi

    if [[ ${MINS} -eq 1 ]]; then
        TIME_STRING+="1 MINUTE"
    else
        TIME_STRING+="${MINS} MINUTES"
    fi

    if [[ ${SECS} -eq 1 && -n ${HOURS} ]]; then
        TIME_STRING+=", AND 1 SECOND"
    elif [[ ${SECS} -eq 1 && -z ${HOURS} ]]; then
        TIME_STRING+=" AND 1 SECOND"
    elif [[ ${SECS} -ne 1 && -n ${HOURS} ]]; then
        TIME_STRING+=", AND ${SECS} SECONDS"
    elif [[ ${SECS} -ne 1 && -z ${HOURS} ]]; then
        TIME_STRING+=" AND ${SECS} SECONDS"
    fi

    echo "${TIME_STRING}"
}

# git clone wrapper
function git_clone() {
    git clone ${DEPTH_FLAG:+"--depth=1"} "${@}"
}


# git fetch wrapper
function git_fetch() {
    git fetch ${DEPTH_FLAG:+"--depth=1"} "${@}"
}

function extract() {
    case "${1}" in
        *.gz) UNPACK=pigz ;;
        *.xz) UNPACK=pxz ;;
    esac
    mkdir -p "${2}"
    ${UNPACK} -d < "${1}" | tar -xC "${2}" --strip-components=1
}

function set_build_state() {
    touch ${BUILD_STATE_DIR}/${1}
}

function check_build_state() {
    if [ -e ${BUILD_STATE_DIR}/${1} ];then
        return 0
    else
        return 1
    fi
}

# Initial setup
function setup_variables() {
    # Colors
    BOLD="\033[1m"
    RED="\033[01;31m"
    RST="\033[0m"
    YLW="\033[01;33m"
    GRN="\033[1;32m"

    JOBS="-j$(($(nproc --all) + 1))"

    # Start of script
    START=$(date +%s)
}

function setup_environment() {
    ROOT="${PWD}"
    PREBUILTS_BIN="${ROOT}/prebuilts/bin"
    SOURCES_DIR="${ROOT}/sources"
    BUILD_STATE_DIR="${ROOT}/state"
    BUILD_DIR="${ROOT}/build_dir"
    INSTALL="${ROOT}/toolchain"

    export PATH=${PREBUILTS_BIN}:${PATH}

    # Maybe not needed!?
    export PATH=${INSTALL}/bin:${PATH}

    mkdir -p ${SOURCES_DIR}
    mkdir -p ${BUILD_STATE_DIR}
}

# Parse parameters
function parse_parameters() {
    while [[ ${#} -ge 1 ]]; do
        case "${1}" in
            # REQUIRED FLAGS
            "-a"|"--arch") shift && ARCH=${1} ;;
            "-s"|"--source") shift && SOURCE=${1} ;;
            "-v"|"--version") shift && VERSION=${1} ;;

            # OPTIONAL FLAGS
            "-f"|"--full-src") FULL_SOURCE=true ;;
            "-nu"|"--no-update") NO_UPDATE=true ;;
            "-p"|"--package") shift && COMPRESSION=${1} ;;
            "-t"|"--tarballs") TARBALLS=true ;;
            "-V"|"--verbose") VERBOSE=true ;;

            # HELP!
            "-h"|"--help") help_menu; exit ;;
        esac

        shift
    done

    [[ -z ${VERBOSE} ]] && exec 6>&2 5>&1 &>/dev/null
    [[ -z ${FULL_SOURCE} ]] && DEPTH_FLAG=true

    # Default values
    case "${ARCH}" in
        "arm") TARGET="arm-linux-gnueabi" ;;
        "arm64") TARGET="aarch64-linux-gnu" ;;
        "x86") TARGET="i686-linux-gnu" ;;
        "x86_64") TARGET="x86_64-linux-gnu" ;;
        "cm4") TARGET="arm-none-eabi" ;;
        *) die "Absent or invalid arch specified!" -h ;;
    esac

    setup_environment

    if [[ -z ${TARBALLS} ]]; then
        # Search for a valid target config
        type -t config_${TARGET} > /dev/null || die "No git config found for ${TARGET}!"
        config_${TARGET} ${SOURCE} ${VERSION} git
    else
        # Search for a valid target config
        type -t config_${TARGET} > /dev/null || die "No tar config found for ${TARGET}!"
        config_${TARGET} ${SOURCE} ${VERSION} tar
    fi
}


function build_binaries() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    local AXEL=${ROOT}/sources/axel
    [[ ! -d ${AXEL} ]] && git -C "$(dirname "${AXEL}")" clone --depth=1 https://github.com/axel-download-accelerator/axel
    git -C "${AXEL}" clean -fxdq
    git -C "${AXEL}" pull
    (
        cd "${AXEL}" || die "Issue with cloning axel source!"
        ./autogen.sh
        ./configure --prefix="$(dirname "${PREBUILTS_BIN}")"
        make ${JOBS} || die "Error building axel!"
        make ${JOBS} install || die "Error installing axel!"
    )

    local PIGZ=${ROOT}/sources/pigz
    [[ ! -d ${PIGZ} ]] && git -C "$(dirname "${PIGZ}")" clone --depth=1 https://github.com/madler/pigz
    git -C "${PIGZ}" clean -fxdq
    git -C "${PIGZ}" pull
    make -C "${PIGZ}" ${JOBS} pigz || die "Error building pigz!"
    mv "${PIGZ}"/pigz "${PREBUILTS_BIN}"

    local PXZ=${ROOT}/sources/pxz
    [[ ! -d ${PXZ} ]] && git -C "$(dirname "${PXZ}")" clone --depth=1 https://github.com/jnovy/pxz
    git -C "${PXZ}" clean -fxdq
    git -C "${PXZ}" pull
    make -C "${PXZ}" ${JOBS} pxz || die "Error building pxz!"
    mv "${PXZ}"/pxz "${PREBUILTS_BIN}"

    set_build_state ${FUNCNAME[0]}
}


function download_sources() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    cd ${SOURCES_DIR} || die "Failed to create sources directory!"

    if [[ -z ${TARBALLS} ]]; then
        if [[ "${IS_BARE_METAL}" = true ]]; then
            if [[ ! -d newlib-${NEWLIB} ]]; then
                header "DOWNLOADING NEWLIB"
                git_clone ${NEWLIB_GIT_URL} newlib-${NEWLIB} -b ${NEWLIB}
            fi
        else
            if [[ ! -d glibc-${GLIBC} ]]; then
                header "DOWNLOADING GLIBC"
                git_clone ${GLIBC_GIT_URL} glibc-${GLIBC} -b ${GLIBC}
            fi

            if [[ ! -d linux-${LINUX} ]]; then
                header "DOWNLOADING LINUX KERNEL"
                git_clone ${LINUX_GIT_URL} linux-${LINUX} -b ${LINUX}
            fi
        fi

        if [[ ! -d binutils-${BINUTILS} ]]; then
            header "DOWNLOADING BINUTILS"
            git_clone ${BINUTILS_GIT_URL} binutils-${BINUTILS} -b ${BINUTILS}
        fi

        if [[ ! -d gcc-${GCC} ]]; then
            header "DOWNLOADING GCC"
            git_clone ${GCC_GIT_URL} gcc-${GCC} -b ${GCC}
        fi
    else
        if [[ "${IS_BARE_METAL}" = true ]]; then
            if [[ ! -f ${NEWLIB}.tar.gz ]]; then
                die "${NEWLIB}.tar.xz"
                header "DOWNLOADING NEWLIB"
                axel ${NEWLIB_BASE_URL}${NEWLIB}.tar.gz
            fi
        else        
            if [[ ! -f ${GLIBC}.tar.xz ]]; then
                header "DOWNLOADING GLIBC"
                axel ${GLIBC_BASE_URL}${GLIBC}.tar.xz
            fi

            if [[ ! -f linux-${LINUX}.tar.xz ]]; then
                header "DOWNLOADING LINUX KERNEL"
                axel ${LINUX_BASE_URL}${LINUX}.tar.xz
            fi
        fi

        if [[ ! -f binutils-${BINUTILS}.tar.xz ]]; then
            header "DOWNLOADING BINUTILS"
            axel ${BINUTILS_BASE_URL}${BINUTILS}.tar.xz
        fi

        if [[ ! -f ${GCC}.tar.gz ]]; then
            header "DOWNLOADING GCC"
            axel ${GCC_BASE_URL}${GCC}.tar.gz
        fi
    fi

    if [[ ! -f ${MPC}.tar.gz ]]; then
        header "DOWNLOADING MPC"
        axel ${MPC_BASE_URL}${MPC}.tar.gz
    fi

    if [[ ! -f ${ISL}.tar.xz ]]; then
        header "DOWNLOADING ISL ${ISL} FOR GCC ${VERSION}"
        axel ${ISL_BASE_URL}${ISL}.tar.xz
    fi

    if [[ ! -f ${MPFR}.tar.xz ]]; then
        header "DOWNLOADING MPFR"
        axel ${MPFR_BASE_URL}${MPFR}.tar.xz
    fi

    if [[ ! -f ${GMP}.tar.xz ]]; then
        header "DOWNLOADING GMP"
        axel ${GMP_BASE_URL}${GMP}.tar.xz
    fi

    cd ${ROOT}

    set_build_state ${FUNCNAME[0]}
}

# Extract tarballs to their proper locations
function extract_sources() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    header "EXTRACTING DOWNLOADED TARBALLS"

    cd ${SOURCES_DIR}

    extract ${MPFR}.tar.xz ${SOURCES_DIR}/mpfr-${MPFR}
    extract ${GMP}.tar.xz ${SOURCES_DIR}/gmp-${GMP}
    extract ${MPC}.tar.gz ${SOURCES_DIR}/mpc-${MPC}
    extract ${ISL}.tar.xz ${SOURCES_DIR}/isl-${ISL}

    if [[ -n ${TARBALLS} ]]; then
        if [[ "${IS_BARE_METAL}" = true ]]; then
            extract ${NEWLIB}.tar.gz ${SOURCES_DIR}/newlib-${NEWLIB}
        else    
            extract ${GLIBC}.tar.xz ${SOURCES_DIR}/glibc-${GLIBC}
            extract linux-${LINUX}.tar.xz ${SOURCES_DIR}/linux-${LINUX}
        fi
        extract binutils-${BINUTILS}.tar.xz ${SOURCES_DIR}/binutils-${BINUTILS}
        extract ${GCC}.tar.gz ${SOURCES_DIR}/gcc-${GCC}
    fi

    set_build_state ${FUNCNAME[0]}
}


# Step 1. Binutils
function build_binutils() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    header "BUILDING BINUTILS"
    mkdir -p ${BUILD_DIR}/build-binutils
    cd ${BUILD_DIR}/build-binutils
    ${SOURCES_DIR}/binutils-${BINUTILS}/configure "${BINUTILS_CONFIGURATION[@]}"
    make ${JOBS} || die "Error while building binutils!" -n

    # case $(uname -m) in
    # 	x86_64) mkdir -v ${INSTALL}/lib && ln -sv lib ${INSTALL}/lib64 ;;
    # esac

    make install ${JOBS} || die "Error while installing binutils!" -n

    set_build_state ${FUNCNAME[0]}
}


# Step 2. Linux Kernel Headers
function build_headers() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    header "MAKING LINUX HEADERS"
    cd ${SOURCES_DIR}/linux-${LINUX} || die "Linux kernel folder does not exist!"
    make ARCH="${ARCH}" \
        INSTALL_HDR_PATH="${INSTALL}/${TARGET}" \
        headers_install ${JOBS} || die "Error while building/installing Linux headers!" -n

    set_build_state ${FUNCNAME[0]}
}


# Step 3. C/C++ Compilers
function build_gcc_stage_1() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    header "MAKING GCC"

    ln -sfn "${SOURCES_DIR}/mpfr-${MPFR}" ${SOURCES_DIR}/gcc-${GCC}/mpfr
    ln -sfn "${SOURCES_DIR}/gmp-${GMP}" ${SOURCES_DIR}/gcc-${GCC}/gmp
    ln -sfn "${SOURCES_DIR}/mpc-${MPC}" ${SOURCES_DIR}/gcc-${GCC}/mpc
    ln -sfn "${SOURCES_DIR}/isl-${ISL}" ${SOURCES_DIR}/gcc-${GCC}/isl

    mkdir -p ${BUILD_DIR}/build-gcc
    cd ${BUILD_DIR}/build-gcc || die "GCC build folder does not exist!"
    ${SOURCES_DIR}/gcc-${GCC}/configure "${GCC_STAGE_1_CONFIGURATION[@]}"
    make ${JOBS} all-gcc || die "Error while building gcc stage1!" -n
    make ${JOBS} install-gcc || die "Error while installing gcc stage1!" -n

    set_build_state ${FUNCNAME[0]}
}


# Build newlib
function build_newlib() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    header "MAKING NEWLIB"

    which arm-none-eabi-ranlib

    mkdir -p ${BUILD_DIR}/build-newlib
    cd ${BUILD_DIR}/build-newlib || die "newlib build folder does not exist!"
    ${SOURCES_DIR}/newlib-${NEWLIB}/configure "${NEWLIB_CONFIGURATION[@]}"
    make all || die "Error while building newlib!" -n
    make install || die "Error while installing newlib!" -n
 
    set_build_state ${FUNCNAME[0]}
}


# Step 4. Standard C Library Headers and Startup Files
function build_glibc_header() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    header "MAKING GLIBC"
    mkdir -p ${BUILD_DIR}/build-glibc
    cd ${BUILD_DIR}/build-glibc || die "glibc build folder does not exist!"
    ${SOURCES_DIR}/glibc-${GLIBC}/configure "${GLIBC_STAGE_1_CONFIGURATION[@]}"

    make install-headers install-bootstrap-headers=yes || die "Error while building glibc headers!" -n
    make ${JOBS} csu/subdir_lib || die "Error while building glibc headers 2!" -n
    install csu/crt1.o csu/crti.o csu/crtn.o ${INSTALL}/${TARGET}/lib || die "Error while installing crt" -n
    ${INSTALL}/bin/${TARGET}-gcc -nostdlib -nostartfiles -shared -x c /dev/null -o ${INSTALL}/${TARGET}/lib/libc.so || die "Error while building libc" -n
    touch ${INSTALL}/${TARGET}/include/gnu/stubs.h

    set_build_state ${FUNCNAME[0]}
}

# Step 5. Compiler Support Library
function build_gcc_stage2() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    header "MAKING GCC INITIAL"

    mkdir -p ${BUILD_DIR}/build-gcc
    cd ${BUILD_DIR}/build-gcc || die "GCC build folder does not exist!"
    make ${JOBS} all-target-libgcc || die "Error while building gcc stage2" -n
    make install-target-libgcc || die "Error while building gcc stage2" -n
 
    set_build_state ${FUNCNAME[0]}
}

# Step 6. Standard C Library & the rest of Glibc
function build_glibc() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    header "MAKING GLIBC"
    cd ${BUILD_DIR}/build-glibc || die "glibc build folder does not exist!"
    make ${JOBS} || die "Error while building glibc"
    make install || die "Error while installing glibc"

    set_build_state ${FUNCNAME[0]}
}

# Step 7. Standard C++ Library & the rest of GCC
function build_gcc_final() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    header "MAKING GCC FINAL"
    mkdir -p ${BUILD_DIR}/build-gcc-final
    cd ${BUILD_DIR}/build-gcc-final || die "GCC build folder does not exist!"
    ${SOURCES_DIR}/gcc-${GCC}/configure "${GCC_STAGE_FINAL_CONFIGURATION[@]}"
    make || die "Error while building gcc final" -n
    make install || die "Error while gcc final install" -n

    set_build_state ${FUNCNAME[0]}
}


configure_gcc_stage_2() {
    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    header "CONFIGURING GCC STAGE 2"

    cd ${BUILD_DIR}/build-gcc || die "GCC build folder does not exist!"
    ${SOURCES_DIR}/gcc-${GCC}/configure "${GCC_STAGE_2_CONFIGURATION[@]}"
 
    set_build_state ${FUNCNAME[0]}
}


# Package toolchain
function package_tc() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    if [[ -n ${COMPRESSION} ]]; then
        PACKAGE=${TARGET}-${VERSION}.x-${SOURCE}-$(TZ=UTC date +%Y%m%d).tar.${COMPRESSION}

        header "PACKAGING TOOLCHAIN"

        echo "Target file: ${PACKAGE}"

        case "${COMPRESSION}" in
            "gz")
                echo "Packaging with GZIP..."
                GZ_OPT=-9 tar -c --use-compress-program=pigz -f "${PACKAGE}" ${TARGET} ;;
            "xz")
                echo "Packaging with XZ..."
                XZ_OPT=-9 tar -c --use-compress-program=pxz -f "${PACKAGE}" ${TARGET} ;;
            *)
                die "Invalid compression specified... skipping" ;;
        esac
    fi

    set_build_state ${FUNCNAME[0]}    
}


# Ending information
function ending_info() {

    check_build_state ${FUNCNAME[0]} && return
    cd ${ROOT}
    # use clean hashtable
    hash -r

    END=$(date +%s)

    [[ -z ${VERBOSE} ]] && exec 1>&5 2>&6
    if [[ -e ${INSTALL}/bin/${TARGET}-gcc ]]; then
        header "BUILD SUCCESSFUL" ${VERBOSE:-"--no-first-echo"}
        echo "${BOLD}Script duration:${RST} $(format_time "${START}" "${END}")"
        echo "${BOLD}GCC version:${RST} $(${INSTALL}/bin/${TARGET}-gcc --version | head -n 1)"
        if [[ -n ${COMPRESSION} ]] && [[ -e ${PACKAGE} ]]; then
            echo "${BOLD}File location:${RST} $(pwd)/${PACKAGE}"
            echo "${BOLD}File size:${RST} $(du -h "${PACKAGE}" | awk '{print $1}')"
        else
            echo "${BOLD}Toolchain location:${RST} $(pwd)/${TARGET}"
        fi
    else
        header "BUILD FAILED"
    fi

    # Alert to script end
    echo "\a"

    set_build_state ${FUNCNAME[0]}
}

parse_parameters "${@}"
setup_variables
build_binaries
download_sources
extract_sources

if [[ "${IS_BARE_METAL}" = true ]]; then
    build_binutils    
    build_gcc
    build_newlib
    # FIXME: check if this is a generic step
    configure_gcc_stage_2
    install_gcc
else
    build_binutils
    build_headers
    build_gcc_stage_1
    build_glibc_header

    build_gcc_stage2
    build_glibc
    build_gcc_final
fi

package_tc
ending_info
